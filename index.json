[{"content":"","date":"July 2, 2022","permalink":"/","section":"Omri Bornstein","summary":"","title":"Omri Bornstein"},{"content":"Current Projects # Go # cocainate is a cross-platform re-implementation of the macOS utility caffeinate that keeps the screen turned on either until stopped, for a set duration of time or while another process still runs. stalk is a cross-platform file-watcher that can run a command after each file-system operation on a given file(s) or simply wait once until a file is changed. rake is a social media scraper that is interfaced via a server-side rendered HTML interface (or a CLI), and is managed by a REST API and a NoSQL database. Other Projects # Research # As part of the FIT2082 unit, I contributed to an existing codebase, based on prior research by (Gange, Harabor and Stuckey, 2021) about Lazy CBS, their Multi-Agent Path Finding (MAPF) algorithm. The MAPF problem is a subset of the path finding research field, which presents the additional requirements of multiple agents, each with a unique pair of sources and targets, such that the path between them, does not intersect with another path during the same point in time. My task was to modify the Lazy CBS codebase such that the algorithm also outputs the final set of constraints that is used to rule out possible paths, such that the Lazy is formally an Explainable Multi-Agent Path Finding (XMAPF) algorithm. In addition, I added Python-to-C++ bindings, such that the compiled Lazy CBS codebase can be used as a Python-facing library for future projects. TypeScript \u0026amp; JavaScript # scr-web (and its scr-cli counterpart) is my previous attempt at building a full-stack social media scraper, which was abandoned due to the excessive number of dependencies and the rather large build-size. Kotlin # sp is my first attempt at building a Minecraft server plugin. This plugin adds the requirement that the player supplies the password (via a server command) before proper server interaction is allowed. Until as password is provided, the currently-unauthorized player is blinded and immobile. Statistics # Project Stars Forks Issues PRs Version License cocainate stalk rake scr-web scr-cli sp FIT2082 ","date":"July 2, 2022","permalink":"/projects/","section":"Projects","summary":"Current Projects # Go # cocainate is a cross-platform re-implementation of the macOS utility caffeinate that keeps the screen turned on either until stopped, for a set duration of time or while another process still runs. stalk is a cross-platform file-watcher that can run a command after each file-system operation on a given file(s) or simply wait once until a file is changed. rake is a social media scraper that is interfaced via a server-side rendered HTML interface (or a CLI), and is managed by a REST API and a NoSQL database.","title":"Projects"},{"content":"","date":"May 8, 2022","permalink":"/tags/bootstrap/","section":"Tags","summary":"","title":"bootstrap"},{"content":"","date":"May 8, 2022","permalink":"/tags/cli/","section":"Tags","summary":"","title":"cli"},{"content":"","date":"May 8, 2022","permalink":"/tags/client/","section":"Tags","summary":"","title":"client"},{"content":"","date":"May 8, 2022","permalink":"/tags/css/","section":"Tags","summary":"","title":"css"},{"content":"","date":"May 8, 2022","permalink":"/tags/docker/","section":"Tags","summary":"","title":"docker"},{"content":"","date":"May 8, 2022","permalink":"/tags/full-stack/","section":"Tags","summary":"","title":"full-stack"},{"content":"","date":"May 8, 2022","permalink":"/tags/go/","section":"Tags","summary":"","title":"go"},{"content":"","date":"May 8, 2022","permalink":"/tags/html/","section":"Tags","summary":"","title":"html"},{"content":"","date":"May 8, 2022","permalink":"/tags/linux/","section":"Tags","summary":"","title":"linux"},{"content":"","date":"May 8, 2022","permalink":"/tags/mac/","section":"Tags","summary":"","title":"mac"},{"content":"","date":"May 8, 2022","permalink":"/projects/rake/","section":"Projects","summary":"","title":"rake"},{"content":"","date":"May 8, 2022","permalink":"/tags/server/","section":"Tags","summary":"","title":"server"},{"content":"","date":"May 8, 2022","permalink":"/projects/stalk/","section":"Projects","summary":"","title":"stalk"},{"content":"","date":"May 8, 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"May 8, 2022","permalink":"/tags/utility/","section":"Tags","summary":"","title":"utility"},{"content":"","date":"May 8, 2022","permalink":"/tags/windows/","section":"Tags","summary":"","title":"windows"},{"content":"","date":"March 12, 2022","permalink":"/projects/cocainate/","section":"Projects","summary":"","title":"cocainate"},{"content":"","date":"August 20, 2021","permalink":"/tags/c/","section":"Tags","summary":"","title":"c"},{"content":"","date":"August 20, 2021","permalink":"/tags/cpp/","section":"Tags","summary":"","title":"cpp"},{"content":"","date":"August 20, 2021","permalink":"/projects/fit2082/","section":"Projects","summary":"","title":"FIT2082 computer science research project"},{"content":"","date":"August 20, 2021","permalink":"/tags/mapf/","section":"Tags","summary":"","title":"mapf"},{"content":"","date":"August 20, 2021","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"","date":"August 20, 2021","permalink":"/tags/research/","section":"Tags","summary":"","title":"research"},{"content":"","date":"August 20, 2021","permalink":"/tags/xmapf/","section":"Tags","summary":"","title":"xmapf"},{"content":"Prompt # Clam decided to return to classic cryptography and revisit the XOR cipher! Here\u0026rsquo;s some hex encoded cipher text:\nae27eb3a148c3cf031079921ea3315cd27eb7d02882bf724169921eb3a469920e07d0b883bf63c018869a5090e8868e331078a68ec2e468c2bf13b1d9a20ea0208882de12e398c2df60211852deb021f823dda35079b2dda25099f35ab7d218227e17d0a982bee7d098368f13503cd27f135039f68e62f1f9d3cea7c The key is 5 bytes long, and the flag is somewhere in the message.\nAnalysis # Assuming 2 hexadecimal digits are equivalent to 1 ASCII characters, a possible key can be found by XORing the ciphertext with the known 5-bytes long substring actf{.\nSolution # In an XOR Cipher, it is known that possible_key = ciphertext ^ known_cleartext. The python script attached:\nslices the ciphertext to all possible 5 characters-long (assuming 2 hexadecimal digits are equivalent to 1 ASCII characters) sections, computes possible_key = ciphertext ^ known_cleartext, for a known substring of actf{, expands the key to the ASCII length of the message, rotates the key to deal with cases where the known clear text is not in an index that is a multiple of the key length. Thanks to @Levon for this suggestion. recomputes the XOR to possibly decode the message and prints the possible message as ASCII. Initial Python Code # from typing import List from doctest import testmod from textwrap import wrap def xor(s: List[int], t: List[int]) -\u0026gt; List[int]: \u0026#34;\u0026#34;\u0026#34; :param s: list of non-negative integers :param t: list of non-negative integers :return: XOR of the ith number of both lists \u0026#34;\u0026#34;\u0026#34; return [a ^ b for a, b in zip(s, t)] def expand_key(short_key: List[int], size: int) -\u0026gt; List[int]: \u0026#34;\u0026#34;\u0026#34; :param short_key: list of non-negative integers :param size: positive integer :return: short_key * (size // len(short_key)) + short_key[:size - len(key_expanded)] \u0026gt;\u0026gt;\u0026gt; expand_key([1, 2, 3, 4, 5], 9) [1, 2, 3, 4, 5, 1, 2, 3, 4] \u0026#34;\u0026#34;\u0026#34; assert size \u0026gt; len(short_key) key_expanded = short_key * (size // len(short_key)) for ii in range(size - len(key_expanded)): key_expanded.append(short_key[ii]) return key_expanded ciphertext_text = input(\u0026#34;hex-encoded ciphertext: \u0026#34;) known_cleartext = input(\u0026#34;known cleartext (with length of key): \u0026#34;) hint = input(\u0026#34;hint (such as \u0026#39;flag\u0026#39;): \u0026#34;) cipher_ascii = [int(letter, 16) for letter in wrap(ciphertext_text, 2)] known_cleartext_ascii = [ord(letter) for letter in known_cleartext] for i in range(len(cipher_ascii) - len(known_cleartext)): key = xor(cipher_ascii[i:i + len(known_cleartext)], known_cleartext_ascii) expanded_key = expand_key(key, len(cipher_ascii)) message_ascii = xor(cipher_ascii, expanded_key) message_text = \u0026#34;\u0026#34;.join(map(chr, message_ascii)) if known_cleartext in message_text and hint in message_text: print(f\u0026#34;key: {key} (\u0026#39;{\u0026#39;\u0026#39;.join(map(chr, key))}\u0026#39;)\u0026#34;) print(f\u0026#34;message: {message_text}\u0026#34;) print() Improved Python Code # from typing import TypedDict, List from textwrap import wrap from pwn import xor class XORSolution(TypedDict): key: List[int] cleartext: str def decode_xor(ciphertext_hex: str, known_cleartext: str, hint: str) -\u0026gt; List[XORSolution]: output = [] cipher_ascii = bytes(int(letter, 16) for letter in wrap(ciphertext_hex, 2)) for i in range(len(cipher_ascii)): key = list(xor(cipher_ascii[i:i + len(known_cleartext)], known_cleartext.encode())) for ii in range(len(key)): rotated_key = key[-ii:] + key[:-ii] cleartext = str(xor(cipher_ascii, rotated_key))[2:-1] if known_cleartext in cleartext and hint in cleartext: output.append({\u0026#34;key\u0026#34;: rotated_key, \u0026#34;cleartext\u0026#34;: cleartext}) return output Python Script Output # A Python script that prints all valid solutions for the full ciphertext and the ciphertext without the first character: ciphertext_hex1 = \u0026#34;ae27eb3a148c3cf031079921ea3315cd27eb7d02882bf724169921eb3a469920e07d0b883bf63c018869a5090e8868e331078a68ec2e468c2bf13b1d9a20ea0208882de12e398c2df60211852deb021f823dda35079b2dda25099f35ab7d218227e17d0a982bee7d098368f13503cd27f135039f68e62f1f9d3cea7c\u0026#34; known_cleartext1 = \u0026#34;actf{\u0026#34; hint1 = \u0026#34;flag\u0026#34; for solution in decode_xor(ciphertext_hex1, known_cleartext1, hint1): print(f\u0026#34;key: {solution[\u0026#39;key\u0026#39;]})\u0026#34;) print(f\u0026#34;message: {solution[\u0026#39;cleartext\u0026#39;]}\u0026#34;) for solution in decode_xor(ciphertext_hex1[2:], known_cleartext1, hint1): print(f\u0026#34;key: {solution[\u0026#39;key\u0026#39;]})\u0026#34;) print(f\u0026#34;message: {solution[\u0026#39;cleartext\u0026#39;]}\u0026#34;) The output of the screen described immediately above: key: [237, 72, 133, 93, 102]) message: Congratulations on decrypting the message! The flag is actf{who_needs_aes_when_you_have_xor}. Good luck on the other crypto! key: [72, 133, 93, 102, 237]) message: ongratulations on decrypting the message! The flag is actf{who_needs_aes_when_you_have_xor}. Good luck on the other crypto! Flag: actf{who_needs_aes_when_you_have_xor}\nReferences # Szymański, Ł. (2021). ångstromCTF 2021: Exclusive Cipher. szymanski.ninja. https://szymanski.ninja/en/ctfwriteups/2021/angstromctf/exclusive-cipher/ ","date":"May 31, 2021","permalink":"/posts/angstromctf-exclusive-cipher/","section":"Posts","summary":"Prompt # Clam decided to return to classic cryptography and revisit the XOR cipher! Here\u0026rsquo;s some hex encoded cipher text:\nae27eb3a148c3cf031079921ea3315cd27eb7d02882bf724169921eb3a469920e07d0b883bf63c018869a5090e8868e331078a68ec2e468c2bf13b1d9a20ea0208882de12e398c2df60211852deb021f823dda35079b2dda25099f35ab7d218227e17d0a982bee7d098368f13503cd27f135039f68e62f1f9d3cea7c The key is 5 bytes long, and the flag is somewhere in the message.\nAnalysis # Assuming 2 hexadecimal digits are equivalent to 1 ASCII characters, a possible key can be found by XORing the ciphertext with the known 5-bytes long substring actf{.\nSolution # In an XOR Cipher, it is known that possible_key = ciphertext ^ known_cleartext.","title":"ångstromCTF Exclusive Cipher"},{"content":"","date":"May 31, 2021","permalink":"/tags/cryptography/","section":"Tags","summary":"","title":"cryptography"},{"content":"","date":"May 31, 2021","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"June 29, 2020","permalink":"/tags/kotlin/","section":"Tags","summary":"","title":"kotlin"},{"content":"","date":"June 29, 2020","permalink":"/tags/minecraft/","section":"Tags","summary":"","title":"minecraft"},{"content":"","date":"June 29, 2020","permalink":"/projects/sp/","section":"Projects","summary":"","title":"sp"},{"content":"","date":"September 30, 2019","permalink":"/tags/angular/","section":"Tags","summary":"","title":"angular"},{"content":"","date":"September 30, 2019","permalink":"/tags/ionic/","section":"Tags","summary":"","title":"ionic"},{"content":"","date":"September 30, 2019","permalink":"/tags/nestjs/","section":"Tags","summary":"","title":"nestjs"},{"content":"","date":"September 30, 2019","permalink":"/tags/nx/","section":"Tags","summary":"","title":"nx"},{"content":"","date":"September 30, 2019","permalink":"/projects/scr-web/","section":"Projects","summary":"","title":"scr-web"},{"content":"","date":"September 30, 2019","permalink":"/tags/typescript/","section":"Tags","summary":"","title":"typescript"},{"content":"","date":"April 18, 2019","permalink":"/projects/scr-cli/","section":"Projects","summary":"","title":"scr-cli"},{"content":"","date":"January 1, 1","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]